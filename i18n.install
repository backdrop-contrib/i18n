<?php

/**
 * @file
 * Installation file for Internationalization (i18n) module.
 */

/**
 * Implements hook_install().
 */
function i18n_install() {
  // Set module weight for it to run after core modules.
  db_query("UPDATE {system} SET weight = 10 WHERE name = 'i18n' AND type = 'module'");
}

/**
 * Add fields to the schema if they don't exist.
 *
 * @param string $table
 *   The name of the database table.
 * @param array $fields
 *   The list of database fields to create.
 * @param bool $force_rebuild_schema
 *   Whether to force backdrop_get_schema() to rebuild the schema. This may be
 *   necessary when additional implementations of hook_schema_alter() have
 *   become available since the schema was originally built.
 */
function i18n_install_create_fields($table, $fields, $force_rebuild_schema = FALSE) {
  static $schema;
  $rebuild_schema = !isset($schema) || $force_rebuild_schema;
  $schema = backdrop_get_schema($table, $rebuild_schema);
  foreach ($fields as $field) {
    if (!empty($schema['fields'][$field])) {
      if (!db_field_exists($table, $field)) {
        db_add_field($table, $field, $schema['fields'][$field]);
      }
      else {
        // The field exists, make sure field definition is up to date.
        db_change_field($table, $field, $field, $schema['fields'][$field]);
      }
    }
  }
}

/**
 * Implements hook_update_last_removed().
 */
function i18n_update_last_removed() {
  return 7001;
}

/**
 * Move book settings from variables to config.
 */
function i18n_update_1000() {
  // Migrate variables to config.
  // $config = config('i18n.settings');
  // $config->set('book_allowed_types', update_variable_get('book_allowed_types', array('book')));
  // $config->save();
  // Delete variables.
  // update_variable_del('book_allowed_types');.
}

/**
 * Get the config translatables from variable_store.
 */
function i18n_update_1001() {
  // Check _config_translatables for all config files.
  $config_info_all = config_get_info();
  foreach ($config_info_all as $prefix => $config_info) {
    $config = config($prefix);
    if ($config->get('_config_translatables') !== NULL) {
      foreach ($config->get('_config_translatables') as $translatable) {
        // Trigger staging for locale.
        // At this point the result is untranslated but that's okay.
        $t = locale($config->get($translatable), 'config:' . $prefix . ':' . $translatable);
        $lid = db_select('locales_source', 'ls')
          ->fields('ls', array('lid'))
          ->condition('ls.context', 'config:' . $prefix . ':' . $translatable, '=')
          ->execute()
          ->fetchField();

        if (empty($lid)) {
          continue;
        }
        // Get translations from variable_store for each language
        // skip the default language
        $default_language = language_default();
        // @todo Convert the name to include the prefix but in d7 format.
        // user.mail.cancel_confirm_body should be user_mail_cancel_confirm_body
        // For now we just find the fuzzy name.
        $translations = db_select('variable_store', 'vs')
          ->fields('vs', array('realm_key', 'value'))
          ->condition('vs.name', '%' . db_like($translatable) . '%', 'LIKE')
          ->condition('vs.realm_key', $default_language->langcode, '<>')
          ->execute()
          ->fetchAll();

        // Create locales_target for each language
        foreach ($translations as $translation) {
          db_insert('locales_target')
          ->fields(array(
            'lid' => $lid,
            'translation' => $translation->value,
            'language' => $translation->realm_key,
          ))
          ->execute();
        }

      }
    }
  }
}